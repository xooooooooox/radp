#!/usr/bin/env bash
set -euo pipefail

# shellcheck disable=SC2155
readonly g_cur_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC2155
readonly g_project_home="$(cd "${g_cur_dir}/.." && pwd)"
##############################################################################
# TODO: 根据实际情况修改默认值
# Defaults – everything can still be overridden from the CLI
##############################################################################
g_app_name="${appName}" # TODO
g_runtime_env="local"
g_platforms="linux/amd64,linux/arm64"

g_registry="${imageRegistry}" #TODO
g_namespace="${imageNamespace}/${g_runtime_env}" #TODO

g_artifactory_domain=""
g_artifactory_username=""
g_artifactory_password=""

g_local_cache_dir="$HOME/.docker/buildx/cache/${g_app_name}"
g_remote_cache_ref="${g_registry}/${g_namespace}/${g_app_name}:cache"

g_context_dir="${g_project_home}"
g_dockerfile="${g_cur_dir}/Dockerfile"

g_build_type="multi"  # one of: single | multi | platform
g_media_type="auto"   # auto | oci | docker
g_enable_sbom="false" # whether to enable SBOM generation
g_extra_build_args="" # additional build args in format "KEY1=VALUE1,KEY2=VALUE2"
g_skip_default_args="false" # whether to skip default build args

##############################################################################
# Helpers
##############################################################################
log() { printf '[%s] %s\n' "$(date +'%F %T')" "$*" >&2; }
die() {
  log "ERROR: $*"
  exit 1
}

get_project_version() {
  local pom_file="${g_project_home}/pom.xml"
  if [[ ! -f "$pom_file" ]]; then
    die "POM file not found at $pom_file"
  fi

  # Extract version from pom.xml using grep and sed
  local version
  version=$(grep -A1 "<artifactId>${g_app_name}</artifactId>" "$pom_file" |
    grep "<version>" |
    sed -E 's/.*<version>(.*)<\/version>.*/\1/')

  if [[ -z "$version" ]]; then
    die "Could not extract version from $pom_file"
  fi

  echo "${version%-*}"
}

usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Options
  -e, --env ENV                Runtime environment (default: $g_runtime_env)
  -r, --registry REGISTRY      Docker registry       (default: $g_registry)
  -n, --namespace NS           Registry namespace    (default: $g_namespace)
  -a, --app-name NAME          Application name      (default: $g_app_name)
  -p, --platforms PLATFORMS    Comma-separated list  (default: $g_platforms)
  -c, --cache DIR              Local cache dir       (default: $g_local_cache_dir)
  -d, --artifactory-domain DOM Artifactory domain    (default: $g_artifactory_domain)
  -u, --artifactory-user USER  Artifactory username  (default: $g_artifactory_username)
  -P, --artifactory-pass PASS  Artifactory password
  -f, --dockerfile PATH        Custom Dockerfile     (default: $g_dockerfile)
  -t, --type TYPE              build type: single | multi | platform
  --media MODE                 MediaType: auto|oci|docker (default: auto)
  --sbom true|false            Enable/disable SBOM generation (default: $g_enable_sbom)
  --build-args ARGS            Extra build args: "KEY1=VALUE1,KEY2=VALUE2"
  --skip-default-args          Skip default build arguments
  -h, --help                   Show this message

Examples
  $0                               # multi-arch build + push with defaults
  $0 -e prod -p linux/arm64        # prod image for arm64 only
  $0 -t single                     # build for current host arch only
  $0 --sbom false                  # build without SBOM generation
  $0 -t push                       # (re-)push latest local image
EOF
}

##############################################################################
# Argument parsing
##############################################################################
parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    -e | --env)
      g_runtime_env=$2
      shift 2
      ;;
    -d | --artifactory-domain)
      g_artifactory_domain=$2
      shift 2
      ;;
    -u | --artifactory-user)
      g_artifactory_username=$2
      shift 2
      ;;
    -P | --artifactory-pass)
      g_artifactory_password=$2
      shift 2
      ;;
    -r | --registry)
      g_registry=$2
      shift 2
      ;;
    -n | --namespace)
      g_namespace=$2
      shift 2
      ;;
    -a | --app-name)
      g_app_name=$2
      shift 2
      ;;
    -p | --platforms)
      g_platforms=$2
      shift 2
      ;;
    -c | --cache)
      g_local_cache_dir=$2
      shift 2
      ;;
    -f | --dockerfile)
      g_dockerfile=$2
      shift 2
      ;;
    -t | --type)
      g_build_type=$2
      shift 2
      ;;
    --sbom)
      g_enable_sbom=$2
      shift 2
      ;;
    --media)
      g_media_type=$2
      shift 2
      ;;
    --build-args)
      g_extra_build_args=$2
      shift 2
      ;;
    --skip-default-args)
      g_skip_default_args="true"
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *) die "Unknown option: $1" ;;
    esac
  done

  # Variables derived from the flags above
  g_namespace="${g_namespace:-x9x/${g_runtime_env}}"
  g_remote_cache_ref="${g_registry}/${g_namespace}/${g_app_name}:cache"
}

validate_args() {
  # Check required string variables with CLI hints
  if [[ -z "$g_app_name" ]]; then
    die "Application name cannot be empty. Use: -a, --app-name NAME"
  fi

  if [[ -z "$g_runtime_env" ]]; then
    die "Runtime environment cannot be empty. Use: -e, --env ENV"
  fi

  if [[ -z "$g_platforms" ]]; then
    die "Platforms cannot be empty. Use: -p, --platforms PLATFORMS"
  fi

  if [[ -z "$g_registry" ]]; then
    die "Docker registry cannot be empty. Use: -r, --registry REGISTRY"
  fi

  if [[ -z "$g_namespace" ]]; then
    die "Registry namespace cannot be empty. Use: -n, --namespace NS"
  fi

  if [[ -z "$g_artifactory_domain" ]]; then
    die "Artifactory domain cannot be empty. Use: -d,--artifactory-domain ARTIFACTORY_DOMAIN"
  fi

  if [[ -z "$g_artifactory_username" ]]; then
    die "Artifactory username cannot be empty. Use: -u, --artifactory-user USER"
  fi

  if [[ -z "$g_local_cache_dir" ]]; then
    die "Local cache directory cannot be empty. Use: -c, --cache DIR"
  fi

  if [[ -z "$g_context_dir" ]]; then
    die "Context directory cannot be empty (derived from project home)"
  fi

  if [[ -z "$g_dockerfile" ]]; then
    die "Dockerfile path cannot be empty. Use: -f, --dockerfile PATH"
  fi

  if [[ -z "$g_build_type" ]]; then
    die "Build type cannot be empty. Use: -t, --type TYPE (single|multi|platform)"
  fi

  # Validate build type is one of the allowed values
  case "$g_build_type" in
  single | multi | platform) ;;
  *) die "Build type must be one of: single, multi, platform. Use: -t, --type TYPE" ;;
  esac

  [[ $g_media_type =~ ^(auto|oci|docker)$ ]] ||
    die "Media mode must be auto|oci|docker"

  # figure out media type if auto
  if [[ $g_media_type == auto ]]; then
    if [[ $g_registry =~ (harbor|registry|docker|ghcr) ]]; then
      g_media_type=oci
    else
      g_media_type=docker # 针对 JFrog docker-type / 旧 Harbor
    fi
    log "Media mode auto-detected → $g_media_type"
  fi

  # Check if dockerfile exists
  if [[ ! -f "$g_dockerfile" ]]; then
    die "Dockerfile not found at: $g_dockerfile. Use: -f, --dockerfile PATH"
  fi

  # Check if context directory exists
  if [[ ! -d "$g_context_dir" ]]; then
    die "Context directory not found at: $g_context_dir"
  fi

  # Interactive password prompt if empty
  if [[ -z "$g_artifactory_password" ]]; then
    read -srp "please input artifactory password for user '$g_artifactory_username': " g_artifactory_password
    echo ""
    # Validate password was actually entered
    if [[ -z "$g_artifactory_password" ]]; then
      die "Artifactory password cannot be empty. Use: -P, --artifactory-pass PASS"
    fi
  fi

  # Validate extra build args format
  parse_extra_build_args
}

##############################################################################
# Cache helpers
##############################################################################
ensure_cache_dirs() {
  log "Ensuring cache directories exist..."
  local p slug
  local -a _plats
  IFS=',' read -ra _plats <<<"$1"
  for p in "${_plats[@]}"; do
    slug="${p//\//-}"
    mkdir -pv "$g_local_cache_dir/$slug"
  done
}

cache_from_flags() {
  local p slug
  local -a _plats _flags
  IFS=',' read -ra _plats <<<"$1"
  for p in "${_plats[@]}"; do
    slug="${p//\//-}"
    _flags+=("--cache-from" "type=local,src=$g_local_cache_dir/$slug")
  done
  for p in "${_plats[@]}"; do
    slug="${p//\//-}"
    _flags+=("--cache-from" "type=registry,ref=$g_remote_cache_ref-$slug")
  done
  printf '%s\n' "${_flags[@]}"
}

##############################################################################
# Build arguments helpers
##############################################################################
declare -a g_build_args_array

# Parse and validate extra build args
parse_extra_build_args() {
  local -a extra_args
  if [[ -n "$g_extra_build_args" ]]; then
    IFS=',' read -ra extra_args <<<"$g_extra_build_args"
    local arg
    for arg in "${extra_args[@]}"; do
      if [[ ! $arg =~ ^[A-Za-z_][A-Za-z0-9_]*=.*$ ]]; then
        die "Invalid build arg format: '$arg'. Expected format: KEY=VALUE"
      fi
    done
  fi
}

# Build the complete build arguments array
make_build_args() {
  g_build_args_array=()

  # Add default build args unless skipped
  if [[ "$g_skip_default_args" != "true" ]]; then
    g_build_args_array+=(
      "--build-arg" "RUNTIME_ENV=$g_runtime_env"
      "--build-arg" "ARTIFACTORY_DOMAIN=$g_artifactory_domain"
      "--build-arg" "ARTIFACTORY_USERNAME=$g_artifactory_username"
      "--build-arg" "ARTIFACTORY_PASSWORD=$g_artifactory_password"
    )

    # Add BUILDKIT_INLINE_CACHE for buildx builds
    if command -v docker >/dev/null && docker buildx version >/dev/null 2>&1; then
      g_build_args_array+=("--build-arg" "BUILDKIT_INLINE_CACHE=1")
    fi
  fi

  # Add extra build args if provided
  if [[ -n "$g_extra_build_args" ]]; then
    local -a extra_args
    IFS=',' read -ra extra_args <<<"$g_extra_build_args"
    local arg
    for arg in "${extra_args[@]}"; do
      g_build_args_array+=("--build-arg" "$arg")
    done
  fi
}

##############################################################################
# Image tags / Buildx exporter helpers
##############################################################################
declare -a g_tags
make_tags() {
  local project_version
  project_version=$(get_project_version)

  g_tags=(
    "${g_registry}/${g_namespace}/${g_app_name}:latest"
    "${g_registry}/${g_namespace}/${g_app_name}:${project_version}"
  )
}

# Generate buildx --output / -t ... related parameters
make_output_args() {
  local -n _out=$1 # bash NAMEREF for returning array
  if [[ $g_media_type == oci ]]; then
    # Concise approach: multiple tags + --push
    _out=(-t "${g_tags[0]}" -t "${g_tags[1]}" --push)
  else
    # Docker-MediaType: explicit registry exporter with multiple name parameters
    local output_str="type=registry"
    local tag
    for tag in "${g_tags[@]}"; do
      output_str+=",name=$tag"
    done
    output_str+=",oci-mediatypes=false,provenance=false,push=true"
    _out=(--output "$output_str")
  fi
}

##############################################################################
# Build targets
##############################################################################
build_single() {
  log "Building single-arch image for $(uname -m)…"
  make_tags
  make_build_args
  local -a out_flags
  make_output_args out_flags

  log "Build args: ${g_build_args_array[*]}"

  # Note: regular docker build doesn't support --output, so we use buildx for consistency
  docker buildx build \
    --sbom="$g_enable_sbom" \
    "${g_build_args_array[@]}" \
    -f "$g_dockerfile" \
    "${out_flags[@]}" \
    "$g_context_dir"
}

build_platform() { # one arch at a time (keeps caches hot)
  local plat="$1"
  log "Building platform-specific image for $plat ..."
  local slug=${1//\//-}

  # Ensure cache directory exists
  ensure_cache_dirs "$plat"

  # Create platform-specific tags
  local project_version
  project_version=$(get_project_version)
  g_tags=(
    "${g_registry}/${g_namespace}/${g_app_name}:${slug}"
    "${g_registry}/${g_namespace}/${g_app_name}:${project_version}-${slug}"
  )

  local -a out_flags
  make_output_args out_flags

  make_build_args
  log "Build args: ${g_build_args_array[*]}"

  docker buildx build \
    --sbom="$g_enable_sbom" \
    --platform "$plat" \
    --cache-from type=local,src="$g_local_cache_dir/$slug" \
    --cache-from type=registry,ref="$g_remote_cache_ref-$slug" \
    --cache-to type=local,dest="$g_local_cache_dir/$slug",compression=zstd,mode=max \
    --cache-to type=registry,ref="$g_remote_cache_ref-$slug",mode=max \
    "${g_build_args_array[@]}" \
    -f "$g_dockerfile" \
    "${out_flags[@]}" \
    "$g_context_dir"
}

build_multi() { # buildx – all targets in one go
  log "Building multi-arch image for: $g_platforms …"

  # Ensure cache directory exists
  ensure_cache_dirs "$g_platforms"

  # Get cache flags as an array
  local -a cache_flags
  mapfile -t cache_flags < <(cache_from_flags "$g_platforms")

  make_tags
  local -a out_flags
  make_output_args out_flags

  make_build_args
  log "Build args: ${g_build_args_array[*]}"

  # Build multi-platform image
  docker buildx build \
    --sbom="$g_enable_sbom" \
    --platform "$g_platforms" \
    "${cache_flags[@]}" \
    --build-arg BUILDKIT_INLINE_CACHE=1 \
    --file "${g_dockerfile}" \
    "${g_build_args_array[@]}" \
    "${out_flags[@]}" \
    "$g_context_dir"

  # Write to the platform-specific cache
  log "Writing platform-specific caches..."
  local -a platform_array
  IFS=',' read -ra platform_array <<<"$g_platforms"
  local p
  for p in "${platform_array[@]}"; do
    build_platform "$p"
  done
}

##############################################################################
# Main
##############################################################################
main() {
  parse_args "$@"
  validate_args

  case "$g_build_type" in
  single) build_single ;;
  multi) build_multi ;;
  platform)
    local -a _plats
    IFS=',' read -ra _plats <<<"$g_platforms"
    local p
    for p in "${_plats[@]}"; do
      build_platform "$p"
    done
    ;;
  *) die "Unknown build type: $g_build_type" ;;
  esac
}

main "$@"
